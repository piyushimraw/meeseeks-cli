import fs from 'fs/promises';
import path from 'path';
import type { PrimeFile, TechStack, MetaPromptExtension } from './types.js';

export interface TemplateVariables {
  techStack?: TechStack;
  projectRoot: string;
  extension: MetaPromptExtension;
  targetDir: string;
}

/**
 * Load a prime prompt template file
 */
export async function loadPrimeTemplate(
  primeFileName: PrimeFile['name'],
  extension: MetaPromptExtension
): Promise<string> {
  const templatePath = path.join(
    process.cwd(),
    'src',
    'templates',
    extension,
    'prime',
    `${primeFileName}.prompt.md`
  );

  try {
    const content = await fs.readFile(templatePath, 'utf-8');
    return content;
  } catch (error) {
    throw new Error(`Failed to load prime template ${primeFileName}: ${error}`);
  }
}

/**
 * Generate template variables for prompt rendering
 */
export function generateTemplateVariables(
  techStack: TechStack,
  projectRoot: string,
  extension: MetaPromptExtension
): TemplateVariables {
  const targetDir = extension === 'roocode' ? '.roo' : '.kilo';

  return {
    techStack,
    projectRoot,
    extension,
    targetDir,
  };
}

/**
 * Generate a placeholder stub for a prime file
 *
 * This creates an initial markdown file that will be replaced
 * when the actual analysis runs via Claude with the prompt template.
 */
export function generatePrimeStub(
  primeFileName: PrimeFile['name'],
  techStack: TechStack
): string {
  const timestamp = new Date().toISOString();

  const stubs: Record<PrimeFile['name'], string> = {
    ARCHITECTURE: `# Architecture

*This file will be generated by running the /prime command.*

## Overview
This codebase uses ${techStack.runtime} with ${techStack.frameworks.join(', ')}.

Architecture analysis pending...

---
*Generated: ${timestamp}*
*Run \`/prime\` to analyze the codebase architecture*
`,

    CONVENTION: `# Coding Conventions

*This file will be generated by running the /prime command.*

## Language
${techStack.language || 'Unknown'}

## Frameworks
${techStack.frameworks.join(', ')}

Coding convention analysis pending...

---
*Generated: ${timestamp}*
*Run \`/prime\` to analyze coding conventions*
`,

    INTEGRATION: `# External Integrations

*This file will be generated by running the /prime command.*

## Tech Stack
- Runtime: ${techStack.runtime}
- Package Manager: ${techStack.packageManager || 'Unknown'}

Integration analysis pending...

---
*Generated: ${timestamp}*
*Run \`/prime\` to analyze external integrations*
`,

    STACK: `# Technology Stack

*This file will be generated by running the /prime command.*

## Detected Stack
- **Runtime:** ${techStack.runtime}
- **Language:** ${techStack.language || 'Unknown'}
- **Package Manager:** ${techStack.packageManager || 'Unknown'}
- **Frameworks:** ${techStack.frameworks.join(', ')}
${techStack.testFramework ? `- **Test Framework:** ${techStack.testFramework}` : ''}
${techStack.buildTool ? `- **Build Tool:** ${techStack.buildTool}` : ''}

Full stack analysis pending...

---
*Generated: ${timestamp}*
*Run \`/prime\` to analyze the full technology stack*
`,

    STRUCTURE: `# Codebase Structure

*This file will be generated by running the /prime command.*

## Project Type
${techStack.runtime} project with ${techStack.frameworks.join(', ')}

Structure analysis pending...

---
*Generated: ${timestamp}*
*Run \`/prime\` to analyze codebase structure*
`,
  };

  return stubs[primeFileName];
}

/**
 * Get all prime file names in order
 */
export function getAllPrimeFileNames(): PrimeFile['name'][] {
  return ['ARCHITECTURE', 'CONVENTION', 'INTEGRATION', 'STACK', 'STRUCTURE'];
}

/**
 * Parse frontmatter from a prompt template
 */
export interface PromptFrontmatter {
  agent: string;
  model: string;
  tools: string[];
  description: string;
  output: string;
}

export function parsePromptFrontmatter(templateContent: string): PromptFrontmatter | null {
  const frontmatterMatch = templateContent.match(/^---\n([\s\S]*?)\n---/);

  if (!frontmatterMatch) {
    return null;
  }

  const frontmatter = frontmatterMatch[1];
  const lines = frontmatter.split('\n');

  const parsed: Partial<PromptFrontmatter> = {
    tools: [],
  };

  let currentKey: keyof PromptFrontmatter | null = null;

  for (const line of lines) {
    if (line.startsWith('agent:')) {
      parsed.agent = line.replace('agent:', '').trim();
    } else if (line.startsWith('model:')) {
      parsed.model = line.replace('model:', '').trim();
    } else if (line.startsWith('description:')) {
      parsed.description = line.replace('description:', '').trim();
    } else if (line.startsWith('output:')) {
      parsed.output = line.replace('output:', '').trim();
    } else if (line.startsWith('tools:')) {
      currentKey = 'tools';
    } else if (currentKey === 'tools' && line.trim().startsWith('-')) {
      const tool = line.trim().replace(/^-\s*/, '');
      parsed.tools!.push(tool);
    }
  }

  if (!parsed.agent || !parsed.model || !parsed.description || !parsed.output) {
    return null;
  }

  return parsed as PromptFrontmatter;
}
